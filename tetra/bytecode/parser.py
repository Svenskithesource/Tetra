"""
An interpreted language

Created by: svenskithesource (https://github.com/Svenskithesource), Jaxp (https://github.com/jaxp2)
"""

from .opcodes import *
from ..asts.ast import *
from ..asts.transformer import NodeTransformer
from ..asts.visitor import NodeVisitor
import typing


class Code:
    """All information about the code.
    The bytecode is a list of tuples, where the first item is the opcode and the second item is the index to the constant in the consts list.
    This object will be generated by the bytecode parser."""

    def __init__(self, name: str, bytecode: typing.List[typing.Tuple[Opcode, typing.Optional[int]]],
                 consts: typing.List[int],
                 vars: typing.List[str]):  # Second item in the tuple is the index to the constant in the consts list
        self.name = name
        self.bytecode = bytecode
        self.consts = consts
        self.vars = vars

    def __str__(self):
        return f"Code(name={self.name}, bytecode={self.bytecode}, consts={self.consts})"


class Simplifier(NodeTransformer):
    def __init__(self):
        self.simplifications = 0

    def visit_Add(self, node: Add):
        if isinstance(node.left, IntegerLiteral) and isinstance(node.right, IntegerLiteral):
            self.simplifications += 1
            return IntegerLiteral(0, node.left.value + node.right.value)

        return node

    def visit_Sub(self, node: Add):
        if isinstance(node.left, IntegerLiteral) and isinstance(node.right, IntegerLiteral):
            self.simplifications += 1
            return IntegerLiteral(0, node.left.value - node.right.value)

        return node

    def visit_Mul(self, node: Add):
        if isinstance(node.left, IntegerLiteral) and isinstance(node.right, IntegerLiteral):
            self.simplifications += 1
            return IntegerLiteral(0, node.left.value * node.right.value)

        return node

    def visit_Div(self, node: Add):
        if isinstance(node.left, IntegerLiteral) and isinstance(node.right, IntegerLiteral):
            self.simplifications += 1
            return IntegerLiteral(0, node.left.value // node.right.value)

        return node


class IndexRecalculator(NodeTransformer):
    def __init__(self):
        self.constants = []

    def visit_IntegerLiteral(self, node):
        if node.value not in self.constants:
            self.constants.append(node.value)

        return IntegerLiteral(index=self.constants.index(node.value), value=node.value)

    def visit_String(self, node):
        if node.value not in self.constants:
            self.constants.append(node.value)

        return String(index=self.constants.index(node.value), value=node.value)


class Parser(NodeVisitor):
    """The parser is a visitor that generates the code object."""

    def __init__(self, ast: Module):
        self.ast = ast
        self.bytecode = []

    def visit_Module(self, node: Module):
        for child in node.body:
            self.visit(child)

    def visit_String(self, node: String):
        self.bytecode.append((Opcode.LOAD_CONST, node.index))

    def visit_IntegerLiteral(self, node: IntegerLiteral):
        self.bytecode.append((Opcode.LOAD_CONST, node.index))

    def visit_Add(self, node: Add):
        self.visit(node.left)
        self.visit(node.right)
        self.bytecode.append((Opcode.ADD, None))

    def visit_Sub(self, node: Sub):
        self.visit(node.left)
        self.visit(node.right)
        self.bytecode.append((Opcode.SUB, None))

    def visit_Mul(self, node: Mul):
        self.visit(node.left)
        self.visit(node.right)
        self.bytecode.append((Opcode.MUL, None))

    def visit_Div(self, node: Div):
        self.visit(node.left)
        self.visit(node.right)
        self.bytecode.append((Opcode.DIV, None))

    def visit_Store(self, node: Store):
        self.visit(node.value)
        self.bytecode.append((Opcode.STORE_VAR, node.index))

    def visit_Load(self, node: Load):
        self.bytecode.append((Opcode.LOAD_VAR, node.index))

    def visit_If(self, node: If):
        self.visit(node.condition)

        cur_index = len(self.bytecode)
        self.bytecode.extend(Parser(Module("if", node.body, self.ast.constants,
                                           self.ast.vars)).get_bytecode())  # The body is a list so we reuse the parser

        self.bytecode.insert(cur_index, (
            Opcode.JUMP_IF_FALSE, len(self.bytecode)))  # Jump to one opcode after the end of the if statement

    def simplify(self):
        simplifier = Simplifier()
        ast = simplifier.visit(self.ast)
        while simplifier.simplifications != 0:
            simplifier = Simplifier()
            ast = simplifier.visit(self.ast)

        indx_calc = IndexRecalculator()
        ast = indx_calc.visit(ast)
        ast.constants = indx_calc.constants

        self.ast = ast

    def get_bytecode(self):  # Put in a function so it can be used for if statements
        self.simplify()
        self.visit(self.ast)

        return self.bytecode

    def parse(self) -> Code:
        self.get_bytecode()
        if self.bytecode[-1][0] != Opcode.RETURN:  # If the last opcode is not a return, add one. Necessary for jumps.
            self.bytecode.append((Opcode.RETURN, None))
        return Code(self.ast.name, self.bytecode, self.ast.constants, self.ast.vars)
